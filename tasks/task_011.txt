# Task ID: 11
# Title: Implement Application State Management
# Status: pending
# Dependencies: 2, 3, 4, 5, 6, 7, 8, 9
# Priority: high
# Description: Create a central state management system to coordinate between different modules and maintain application state.
# Details:
1. Implement a central state manager using the Observer pattern
2. Create state synchronization between UI components
3. Add persistence of user preferences
4. Implement error handling and notification system

Example implementation:
```javascript
// appState.js
export class AppState {
  constructor() {
    this.state = {
      connection: {
        isConnected: false,
        port: null,
        settings: {
          baudRate: 115200,
          dataBits: 8,
          stopBits: 1,
          parity: 'none',
          flowControl: 'none',
          bufferSize: 4096
        }
      },
      monitoring: {
        isActive: false,
        packetTimeout: 50,
        autoScroll: true,
        filterType: 'all'
      },
      session: {
        id: null,
        startTime: null,
        packets: [],
        statistics: null
      },
      ui: {
        theme: 'dark',
        selectedPackets: [],
        notifications: []
      }
    };
    
    this.listeners = {};
    this.loadPreferences();
  }

  // Get a specific part of the state
  get(path) {
    return this._getNestedProperty(this.state, path);
  }

  // Update state and notify listeners
  update(path, value) {
    this._setNestedProperty(this.state, path, value);
    this._notifyListeners(path);
    this.savePreferences();
    return this;
  }

  // Subscribe to state changes
  subscribe(path, callback) {
    if (!this.listeners[path]) {
      this.listeners[path] = [];
    }
    
    this.listeners[path].push(callback);
    
    // Return unsubscribe function
    return () => {
      this.listeners[path] = this.listeners[path].filter(cb => cb !== callback);
    };
  }

  // Add a notification
  notify(message, type = 'info', duration = 5000) {
    const notification = {
      id: Date.now(),
      message,
      type,
      timestamp: new Date()
    };
    
    const notifications = [...this.state.ui.notifications, notification];
    this.update('ui.notifications', notifications);
    
    // Auto-remove after duration
    if (duration > 0) {
      setTimeout(() => {
        this.dismissNotification(notification.id);
      }, duration);
    }
    
    return notification.id;
  }

  // Remove a notification
  dismissNotification(id) {
    const notifications = this.state.ui.notifications.filter(n => n.id !== id);
    this.update('ui.notifications', notifications);
  }

  // Add a packet to the current session
  addPacket(packet) {
    const packets = [...this.state.session.packets, packet];
    this.update('session.packets', packets);
    
    // Update statistics
    if (packets.length % 10 === 0) { // Update stats every 10 packets
      this._updateStatistics();
    }
  }

  // Start a new session
  startSession() {
    const sessionId = 'session_' + Date.now();
    const startTime = new Date();
    
    this.update('session', {
      id: sessionId,
      startTime,
      packets: [],
      statistics: null
    });
    
    return sessionId;
  }

  // End current session and save
  async endSession() {
    if (!this.state.session.id) return null;
    
    const endTime = new Date();
    this.update('session.endTime', endTime);
    this._updateStatistics();
    
    // Save to storage if available
    if (this.dataStorage) {
      try {
        await this.dataStorage.saveSession(this.state.session);
        this.notify('Session saved successfully', 'success');
      } catch (error) {
        console.error('Error saving session:', error);
        this.notify('Failed to save session: ' + error.message, 'error');
      }
    }
    
    return this.state.session.id;
  }

  // Set data storage reference
  setDataStorage(dataStorage) {
    this.dataStorage = dataStorage;
  }

  // Save user preferences to localStorage
  savePreferences() {
    const preferences = {
      connection: {
        settings: this.state.connection.settings
      },
      monitoring: {
        packetTimeout: this.state.monitoring.packetTimeout,
        autoScroll: this.state.monitoring.autoScroll,
        filterType: this.state.monitoring.filterType
      },
      ui: {
        theme: this.state.ui.theme
      }
    };
    
    try {
      localStorage.setItem('modbusMonitorPrefs', JSON.stringify(preferences));
    } catch (error) {
      console.error('Error saving preferences:', error);
    }
  }

  // Load user preferences from localStorage
  loadPreferences() {
    try {
      const prefsJson = localStorage.getItem('modbusMonitorPrefs');
      if (prefsJson) {
        const prefs = JSON.parse(prefsJson);
        
        // Update state with saved preferences
        if (prefs.connection?.settings) {
          this.update('connection.settings', {
            ...this.state.connection.settings,
            ...prefs.connection.settings
          });
        }
        
        if (prefs.monitoring) {
          if (prefs.monitoring.packetTimeout) {
            this.update('monitoring.packetTimeout', prefs.monitoring.packetTimeout);
          }
          if (typeof prefs.monitoring.autoScroll === 'boolean') {
            this.update('monitoring.autoScroll', prefs.monitoring.autoScroll);
          }
          if (prefs.monitoring.filterType) {
            this.update('monitoring.filterType', prefs.monitoring.filterType);
          }
        }
        
        if (prefs.ui?.theme) {
          this.update('ui.theme', prefs.ui.theme);
        }
      }
    } catch (error) {
      console.error('Error loading preferences:', error);
    }
  }

  // Update session statistics
  _updateStatistics() {
    if (!this.state.session.packets.length) return;
    
    const packets = this.state.session.packets;
    const totalPackets = packets.length;
    const txPackets = packets.filter(p => p.direction === 'TX').length;
    const rxPackets = packets.filter(p => p.direction === 'RX').length;
    const invalidPackets = packets.filter(p => !p.parsedData.isValid).length;
    const errorRate = totalPackets > 0 ? (invalidPackets / totalPackets) * 100 : 0;
    
    // Calculate response times
    const responseTimes = [];
    for (let i = 0; i < packets.length - 1; i++) {
      if (packets[i].direction === 'TX' && packets[i+1].direction === 'RX') {
        const responseTime = packets[i+1].timestamp - packets[i].timestamp;
        responseTimes.push(responseTime);
      }
    }
    
    const avgResponseTime = responseTimes.length > 0 ? 
      responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length : 
      0;
    
    const statistics = {
      totalPackets,
      txPackets,
      rxPackets,
      invalidPackets,
      errorRate: errorRate.toFixed(2) + '%',
      avgResponseTime: avgResponseTime.toFixed(2) + 'ms',
      minResponseTime: responseTimes.length > 0 ? Math.min(...responseTimes).toFixed(2) + 'ms' : 'N/A',
      maxResponseTime: responseTimes.length > 0 ? Math.max(...responseTimes).toFixed(2) + 'ms' : 'N/A'
    };
    
    this.update('session.statistics', statistics);
  }

  // Helper to get nested property using dot notation
  _getNestedProperty(obj, path) {
    return path.split('.').reduce((prev, curr) => {
      return prev ? prev[curr] : undefined;
    }, obj);
  }

  // Helper to set nested property using dot notation
  _setNestedProperty(obj, path, value) {
    const parts = path.split('.');
    const lastKey = parts.pop();
    const target = parts.reduce((prev, curr) => {
      if (!prev[curr]) prev[curr] = {};
      return prev[curr];
    }, obj);
    
    target[lastKey] = value;
  }

  // Notify all listeners for a path and its parent paths
  _notifyListeners(path) {
    // Notify specific path listeners
    if (this.listeners[path]) {
      this.listeners[path].forEach(callback => {
        callback(this._getNestedProperty(this.state, path));
      });
    }
    
    // Notify parent path listeners
    const parts = path.split('.');
    while (parts.length > 1) {
      parts.pop();
      const parentPath = parts.join('.');
      
      if (this.listeners[parentPath]) {
        this.listeners[parentPath].forEach(callback => {
          callback(this._getNestedProperty(this.state, parentPath));
        });
      }
    }
    
    // Notify root listeners
    if (this.listeners['*']) {
      this.listeners['*'].forEach(callback => {
        callback(this.state);
      });
    }
  }
}
```

# Test Strategy:
1. Test state updates and listener notifications
2. Verify persistence of user preferences
3. Test notification system
4. Verify state synchronization between components
5. Test session management functionality
6. Verify statistics calculation
7. Test error handling and recovery
8. Verify performance with frequent state updates
