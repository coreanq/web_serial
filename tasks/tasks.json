{
  "tasks": [
    {
      "id": 1,
      "title": "Project Structure and Build Environment Setup",
      "description": "Set up the initial project structure and build environment for the Modbus-RTU Serial Monitor web application.",
      "details": "1. Create a new project directory structure\n2. Initialize package.json\n3. Set up module bundling with Webpack or Rollup\n4. Configure ES6 transpilation with Babel\n5. Include Bootstrap 5.3.0 locally (not via CDN)\n6. Set up CSS preprocessing\n7. Create initial HTML structure with responsive layout\n8. Configure development server\n9. Set up linting and code formatting\n10. Create basic folder structure:\n   - /src\n     - /js\n       - /modules\n     - /css\n     - /assets\n   - /dist\n   - /tests\n\nCode example for index.html:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Web Serial Online - Modbus-RTU Monitor</title>\n  <link rel=\"stylesheet\" href=\"./css/bootstrap.min.css\">\n  <link rel=\"stylesheet\" href=\"./css/styles.css\">\n</head>\n<body class=\"bg-dark text-light\">\n  <header class=\"fixed-top bg-dark border-bottom border-secondary\">\n    <div class=\"container-fluid\">\n      <h1 class=\"h3 py-2 m-0\">Web Serial Online</h1>\n    </div>\n  </header>\n  <div class=\"container-fluid\">\n    <div class=\"row\">\n      <!-- Sidebar for connection settings -->\n      <div class=\"col-md-3 col-lg-2 sidebar\"></div>\n      <!-- Main log area -->\n      <div class=\"col-md-9 col-lg-10 main-content\"></div>\n    </div>\n  </div>\n  <script type=\"module\" src=\"./js/main.js\"></script>\n</body>\n</html>\n```",
      "testStrategy": "1. Verify that all dependencies are correctly installed\n2. Ensure Bootstrap 5.3.0 is properly included locally\n3. Test the development server to ensure it serves the application correctly\n4. Validate HTML structure with W3C validator\n5. Test responsive layout on different screen sizes\n6. Verify that ES6 code transpiles correctly\n7. Run linting to ensure code quality standards",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement Web Serial API Connection Module",
      "description": "Create a module to handle Web Serial API connections, allowing users to select, connect to, and configure serial ports.",
      "details": "1. Create a SerialConnection class to encapsulate Web Serial API functionality\n2. Implement methods for port selection, opening, and closing\n3. Add support for configuring connection parameters (Baud Rate, Data Bits, Stop Bits, Parity)\n4. Implement event handling for connection status changes\n5. Add error handling for connection failures\n6. Create UI components for serial port selection and configuration\n\nExample implementation:\n```javascript\n// serialConnection.js\nexport class SerialConnection {\n  constructor() {\n    this.port = null;\n    this.reader = null;\n    this.writer = null;\n    this.isConnected = false;\n    this.connectionListeners = [];\n  }\n\n  async selectPort() {\n    try {\n      this.port = await navigator.serial.requestPort();\n      return true;\n    } catch (error) {\n      console.error('Error selecting port:', error);\n      return false;\n    }\n  }\n\n  async connect(options = {\n    baudRate: 115200,\n    dataBits: 8,\n    stopBits: 1,\n    parity: 'none',\n    flowControl: 'none'\n  }) {\n    if (!this.port) {\n      throw new Error('No port selected');\n    }\n\n    try {\n      await this.port.open(options);\n      this.reader = this.port.readable.getReader();\n      this.writer = this.port.writable.getWriter();\n      this.isConnected = true;\n      this._notifyConnectionChange();\n      return true;\n    } catch (error) {\n      console.error('Error opening port:', error);\n      this.isConnected = false;\n      this._notifyConnectionChange();\n      throw error;\n    }\n  }\n\n  async disconnect() {\n    if (!this.isConnected) return;\n\n    try {\n      if (this.reader) {\n        await this.reader.cancel();\n        this.reader.releaseLock();\n        this.reader = null;\n      }\n\n      if (this.writer) {\n        this.writer.releaseLock();\n        this.writer = null;\n      }\n\n      await this.port.close();\n      this.isConnected = false;\n      this._notifyConnectionChange();\n    } catch (error) {\n      console.error('Error closing port:', error);\n      throw error;\n    }\n  }\n\n  onConnectionChange(callback) {\n    this.connectionListeners.push(callback);\n    return () => {\n      this.connectionListeners = this.connectionListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  _notifyConnectionChange() {\n    this.connectionListeners.forEach(callback => callback(this.isConnected));\n  }\n}\n```",
      "testStrategy": "1. Test port selection functionality in Chrome browser\n2. Verify connection with different serial parameters\n3. Test error handling with invalid configurations\n4. Verify connection status updates correctly\n5. Test connection/disconnection multiple times\n6. Verify event listeners are properly registered and unregistered\n7. Test with mock serial devices when physical devices are unavailable\n8. Verify UI updates correctly based on connection state",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Serial Data Reception and Transmission",
      "description": "Create a module to handle the reception and transmission of data through the serial connection, including buffer management.",
      "details": "1. Extend the SerialConnection class to handle data reception\n2. Implement a circular buffer for received data\n3. Create methods for sending data in different formats (text, hex)\n4. Add support for different line endings (CR, LF, CRLF)\n5. Implement event-based notification for received data\n6. Add timeout handling for data reception\n\nExample implementation:\n```javascript\n// serialDataHandler.js\nimport { SerialConnection } from './serialConnection.js';\n\nexport class SerialDataHandler extends SerialConnection {\n  constructor() {\n    super();\n    this.receiveBuffer = new Uint8Array(4096);\n    this.bufferPosition = 0;\n    this.dataListeners = [];\n    this.isReading = false;\n  }\n\n  startReading() {\n    if (this.isReading || !this.isConnected) return;\n    \n    this.isReading = true;\n    this._readLoop();\n  }\n\n  async _readLoop() {\n    while (this.isReading && this.reader) {\n      try {\n        const { value, done } = await this.reader.read();\n        \n        if (done) {\n          this.isReading = false;\n          break;\n        }\n        \n        if (value) {\n          this._processReceivedData(value);\n        }\n      } catch (error) {\n        console.error('Error reading data:', error);\n        this.isReading = false;\n        break;\n      }\n    }\n  }\n\n  _processReceivedData(data) {\n    // Add data to buffer\n    for (let i = 0; i < data.length; i++) {\n      this.receiveBuffer[this.bufferPosition] = data[i];\n      this.bufferPosition = (this.bufferPosition + 1) % this.receiveBuffer.length;\n    }\n    \n    // Notify listeners\n    const dataView = new Uint8Array(data);\n    this.dataListeners.forEach(callback => callback({\n      direction: 'RX',\n      timestamp: new Date(),\n      data: dataView\n    }));\n  }\n\n  async sendData(data, isHex = false) {\n    if (!this.isConnected || !this.writer) {\n      throw new Error('Not connected');\n    }\n\n    let dataToSend;\n    if (isHex) {\n      // Convert hex string to bytes\n      const hexString = data.replace(/\\s/g, '');\n      dataToSend = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n    } else {\n      // Convert string to bytes\n      dataToSend = new TextEncoder().encode(data);\n    }\n\n    try {\n      await this.writer.write(dataToSend);\n      \n      // Notify listeners about sent data\n      this.dataListeners.forEach(callback => callback({\n        direction: 'TX',\n        timestamp: new Date(),\n        data: dataToSend\n      }));\n      \n      return true;\n    } catch (error) {\n      console.error('Error sending data:', error);\n      throw error;\n    }\n  }\n\n  onDataReceived(callback) {\n    this.dataListeners.push(callback);\n    return () => {\n      this.dataListeners = this.dataListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  stopReading() {\n    this.isReading = false;\n  }\n}\n```",
      "testStrategy": "1. Test data reception with various input sizes\n2. Verify buffer management with large data streams\n3. Test sending data in both text and hex formats\n4. Verify event notifications are triggered correctly\n5. Test with different baud rates to ensure timing is correct\n6. Verify data integrity by sending and receiving known patterns\n7. Test error handling during transmission and reception\n8. Measure performance with high-speed data streams",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Modbus-RTU Packet Parser",
      "description": "Create a module to parse and validate Modbus-RTU protocol packets, including CRC verification and packet boundary detection.",
      "details": "1. Implement CRC16 calculation for Modbus-RTU\n2. Create packet boundary detection based on timeout\n3. Implement packet structure parsing (slave address, function code, data, CRC)\n4. Add validation for packet integrity\n5. Create data structures for parsed packets\n\nExample implementation:\n```javascript\n// modbusParser.js\nexport class ModbusParser {\n  constructor(packetTimeoutMs = 50) {\n    this.packetTimeoutMs = packetTimeoutMs;\n    this.buffer = [];\n    this.lastByteTime = 0;\n    this.packetListeners = [];\n  }\n\n  processBytes(bytes, timestamp) {\n    const currentTime = timestamp || Date.now();\n    \n    // Check if we need to finalize the previous packet due to timeout\n    if (this.buffer.length > 0 && (currentTime - this.lastByteTime) > this.packetTimeoutMs) {\n      this._finalizePacket();\n    }\n    \n    // Add new bytes to buffer\n    for (const byte of bytes) {\n      this.buffer.push(byte);\n    }\n    \n    this.lastByteTime = currentTime;\n  }\n\n  _finalizePacket() {\n    if (this.buffer.length < 4) {\n      // Not enough bytes for a valid Modbus packet (at least slave address, function code, and 2 CRC bytes)\n      this.buffer = [];\n      return;\n    }\n    \n    const packet = new Uint8Array(this.buffer);\n    this.buffer = [];\n    \n    // Parse the packet\n    const parsedPacket = this._parseModbusPacket(packet);\n    \n    // Notify listeners\n    if (parsedPacket) {\n      this.packetListeners.forEach(callback => callback(parsedPacket));\n    }\n  }\n\n  _parseModbusPacket(packet) {\n    if (packet.length < 4) return null;\n    \n    const slaveAddress = packet[0];\n    const functionCode = packet[1];\n    const data = packet.slice(2, packet.length - 2);\n    const receivedCrc = (packet[packet.length - 1] << 8) | packet[packet.length - 2];\n    const calculatedCrc = this._calculateCRC16(packet.slice(0, packet.length - 2));\n    const isValid = receivedCrc === calculatedCrc;\n    \n    return {\n      timestamp: new Date(),\n      rawData: packet,\n      parsedData: {\n        slaveAddress,\n        functionCode,\n        data,\n        crc: receivedCrc,\n        isValid\n      },\n      interpretation: this._interpretModbusPacket(slaveAddress, functionCode, data, isValid)\n    };\n  }\n\n  _calculateCRC16(buffer) {\n    let crc = 0xFFFF;\n    \n    for (let pos = 0; pos < buffer.length; pos++) {\n      crc ^= buffer[pos];\n      \n      for (let i = 8; i !== 0; i--) {\n        if ((crc & 0x0001) !== 0) {\n          crc >>= 1;\n          crc ^= 0xA001;\n        } else {\n          crc >>= 1;\n        }\n      }\n    }\n    \n    return crc;\n  }\n\n  _interpretModbusPacket(slaveAddress, functionCode, data, isValid) {\n    if (!isValid) return 'Invalid CRC';\n    \n    let interpretation = `Slave: ${slaveAddress}, Function: `;\n    \n    switch (functionCode) {\n      case 1:\n        interpretation += 'Read Coils (01)';\n        break;\n      case 2:\n        interpretation += 'Read Discrete Inputs (02)';\n        break;\n      case 3:\n        interpretation += 'Read Holding Registers (03)';\n        break;\n      case 4:\n        interpretation += 'Read Input Registers (04)';\n        break;\n      case 5:\n        interpretation += 'Write Single Coil (05)';\n        break;\n      case 6:\n        interpretation += 'Write Single Register (06)';\n        break;\n      case 15:\n        interpretation += 'Write Multiple Coils (15)';\n        break;\n      case 16:\n        interpretation += 'Write Multiple Registers (16)';\n        break;\n      default:\n        if (functionCode > 128) {\n          interpretation += `Exception Response (${functionCode - 128})`;\n        } else {\n          interpretation += `Unknown (${functionCode})`;\n        }\n    }\n    \n    return interpretation;\n  }\n\n  onPacketDetected(callback) {\n    this.packetListeners.push(callback);\n    return () => {\n      this.packetListeners = this.packetListeners.filter(cb => cb !== callback);\n    };\n  }\n\n  setPacketTimeout(timeoutMs) {\n    this.packetTimeoutMs = timeoutMs;\n  }\n}\n```",
      "testStrategy": "1. Test CRC16 calculation with known Modbus packets\n2. Verify packet boundary detection with various timeout values\n3. Test parsing of different Modbus function codes\n4. Verify error detection for invalid packets\n5. Test with real Modbus device data samples\n6. Verify handling of exception responses\n7. Test with fragmented packets to ensure proper reassembly\n8. Benchmark parsing performance with large packet streams",
      "priority": "high",
      "dependencies": [
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement Modbus Function Code Interpreter",
      "description": "Create a module to interpret Modbus function codes and provide human-readable explanations of packet contents.",
      "details": "1. Implement detailed interpretation for standard Modbus function codes (01-06, 15-16)\n2. Add support for exception responses\n3. Create register address and value formatting (decimal and hex)\n4. Implement data payload interpretation based on function code\n\nExample implementation:\n```javascript\n// modbusInterpreter.js\nexport class ModbusInterpreter {\n  constructor() {\n    this.functionCodeMap = {\n      1: 'Read Coils',\n      2: 'Read Discrete Inputs',\n      3: 'Read Holding Registers',\n      4: 'Read Input Registers',\n      5: 'Write Single Coil',\n      6: 'Write Single Register',\n      15: 'Write Multiple Coils',\n      16: 'Write Multiple Registers'\n    };\n    \n    this.exceptionCodeMap = {\n      1: 'Illegal Function',\n      2: 'Illegal Data Address',\n      3: 'Illegal Data Value',\n      4: 'Slave Device Failure',\n      5: 'Acknowledge',\n      6: 'Slave Device Busy',\n      8: 'Memory Parity Error',\n      10: 'Gateway Path Unavailable',\n      11: 'Gateway Target Device Failed to Respond'\n    };\n  }\n\n  interpretPacket(packet) {\n    const { slaveAddress, functionCode, data } = packet.parsedData;\n    let interpretation = '';\n    \n    // Check if it's an exception response\n    if (functionCode > 128) {\n      const originalFunctionCode = functionCode - 128;\n      const exceptionCode = data[0];\n      \n      interpretation = `Exception Response - ${this.getFunctionName(originalFunctionCode)}\\n`;\n      interpretation += `Exception: ${this.getExceptionName(exceptionCode)}\\n`;\n      return interpretation;\n    }\n    \n    // Regular function code interpretation\n    interpretation = `${this.getFunctionName(functionCode)}\\n`;\n    \n    switch (functionCode) {\n      case 1: // Read Coils\n      case 2: // Read Discrete Inputs\n        if (data.length === 0) {\n          // Request\n          const startAddress = (data[0] << 8) | data[1];\n          const quantity = (data[2] << 8) | data[3];\n          interpretation += `Start Address: ${startAddress} (0x${startAddress.toString(16)})\\n`;\n          interpretation += `Quantity: ${quantity}\\n`;\n        } else {\n          // Response\n          const byteCount = data[0];\n          interpretation += `Byte Count: ${byteCount}\\n`;\n          interpretation += 'Values: ';\n          \n          for (let i = 1; i <= byteCount; i++) {\n            interpretation += data[i].toString(16).padStart(2, '0') + ' ';\n          }\n        }\n        break;\n        \n      case 3: // Read Holding Registers\n      case 4: // Read Input Registers\n        if (data.length === 4) {\n          // Request\n          const startAddress = (data[0] << 8) | data[1];\n          const quantity = (data[2] << 8) | data[3];\n          interpretation += `Start Address: ${startAddress} (0x${startAddress.toString(16)})\\n`;\n          interpretation += `Quantity: ${quantity}\\n`;\n        } else {\n          // Response\n          const byteCount = data[0];\n          interpretation += `Byte Count: ${byteCount}\\n`;\n          interpretation += 'Register Values:\\n';\n          \n          for (let i = 1; i < data.length; i += 2) {\n            const regValue = (data[i] << 8) | data[i + 1];\n            interpretation += `  ${regValue} (0x${regValue.toString(16).padStart(4, '0')})\\n`;\n          }\n        }\n        break;\n        \n      case 5: // Write Single Coil\n        const outputAddress = (data[0] << 8) | data[1];\n        const outputValue = (data[2] << 8) | data[3];\n        interpretation += `Output Address: ${outputAddress} (0x${outputAddress.toString(16)})\\n`;\n        interpretation += `Value: ${outputValue === 0xFF00 ? 'ON' : 'OFF'}\\n`;\n        break;\n        \n      case 6: // Write Single Register\n        const regAddress = (data[0] << 8) | data[1];\n        const regValue = (data[2] << 8) | data[3];\n        interpretation += `Register Address: ${regAddress} (0x${regAddress.toString(16)})\\n`;\n        interpretation += `Value: ${regValue} (0x${regValue.toString(16).padStart(4, '0')})\\n`;\n        break;\n        \n      // Add cases for 15 and 16 here\n      \n      default:\n        interpretation += 'Detailed interpretation not available\\n';\n    }\n    \n    return interpretation;\n  }\n\n  getFunctionName(functionCode) {\n    return this.functionCodeMap[functionCode] || `Unknown Function (${functionCode})`;\n  }\n\n  getExceptionName(exceptionCode) {\n    return this.exceptionCodeMap[exceptionCode] || `Unknown Exception (${exceptionCode})`;\n  }\n}\n```",
      "testStrategy": "1. Test interpretation of all standard function codes\n2. Verify correct handling of exception responses\n3. Test with various data payloads for each function code\n4. Verify decimal and hexadecimal representations are correct\n5. Test edge cases like maximum register counts\n6. Verify interpretation of real-world Modbus packets\n7. Test with malformed packets to ensure graceful handling\n8. Verify readability and accuracy of human-readable output",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Connection Settings UI",
      "description": "Create the user interface for serial port selection and connection settings, including the left sidebar panel.",
      "details": "1. Create the left sidebar UI for connection settings\n2. Implement dropdown selectors for Baud Rate, Data Bits, Stop Bits, Parity, and Flow Control\n3. Add buttons for port selection and connection/disconnection\n4. Implement status indicators for connection state\n5. Add event handlers for all UI elements\n\nExample implementation:\n```javascript\n// connectionUI.js\nexport class ConnectionUI {\n  constructor(serialConnection) {\n    this.serialConnection = serialConnection;\n    this.isConnected = false;\n    \n    // Cache DOM elements\n    this.sidebar = document.querySelector('.sidebar');\n    \n    // Initialize UI\n    this._createUI();\n    this._attachEventListeners();\n  }\n\n  _createUI() {\n    this.sidebar.innerHTML = `\n      <div class=\"p-3 connection-panel\">\n        <h5 class=\"mb-3\">Connection Settings</h5>\n        \n        <div class=\"mb-3\">\n          <label for=\"baudRate\" class=\"form-label\">Baud Rate</label>\n          <select class=\"form-select form-select-sm\" id=\"baudRate\">\n            <option value=\"9600\">9600</option>\n            <option value=\"19200\">19200</option>\n            <option value=\"38400\">38400</option>\n            <option value=\"57600\">57600</option>\n            <option value=\"115200\" selected>115200</option>\n          </select>\n        </div>\n        \n        <div class=\"mb-3\">\n          <label for=\"dataBits\" class=\"form-label\">Data Bits</label>\n          <select class=\"form-select form-select-sm\" id=\"dataBits\">\n            <option value=\"7\">7</option>\n            <option value=\"8\" selected>8</option>\n          </select>\n        </div>\n        \n        <div class=\"mb-3\">\n          <label for=\"stopBits\" class=\"form-label\">Stop Bits</label>\n          <select class=\"form-select form-select-sm\" id=\"stopBits\">\n            <option value=\"1\" selected>1</option>\n            <option value=\"2\">2</option>\n          </select>\n        </div>\n        \n        <div class=\"mb-3\">\n          <label for=\"parity\" class=\"form-label\">Parity</label>\n          <select class=\"form-select form-select-sm\" id=\"parity\">\n            <option value=\"none\" selected>None</option>\n            <option value=\"even\">Even</option>\n            <option value=\"odd\">Odd</option>\n          </select>\n        </div>\n        \n        <div class=\"mb-3\">\n          <label for=\"flowControl\" class=\"form-label\">Flow Control</label>\n          <select class=\"form-select form-select-sm\" id=\"flowControl\">\n            <option value=\"none\" selected>None</option>\n            <option value=\"hardware\">Hardware</option>\n          </select>\n        </div>\n        \n        <div class=\"mb-3\">\n          <label for=\"buffer\" class=\"form-label\">Buffer</label>\n          <input type=\"text\" class=\"form-control form-control-sm\" id=\"buffer\" value=\"4096\">\n        </div>\n        \n        <div class=\"connection-status mb-3 p-2 bg-dark text-light rounded\">\n          <small id=\"statusText\">No Serial Port Selected</small>\n        </div>\n        \n        <div class=\"d-grid gap-2\">\n          <button id=\"selectPortBtn\" class=\"btn btn-primary btn-sm\">Select Serial Port</button>\n          <button id=\"connectBtn\" class=\"btn btn-success btn-sm\" disabled>Open Serial Port</button>\n        </div>\n      </div>\n    `;\n    \n    // Cache new DOM elements\n    this.statusText = document.getElementById('statusText');\n    this.selectPortBtn = document.getElementById('selectPortBtn');\n    this.connectBtn = document.getElementById('connectBtn');\n    this.baudRateSelect = document.getElementById('baudRate');\n    this.dataBitsSelect = document.getElementById('dataBits');\n    this.stopBitsSelect = document.getElementById('stopBits');\n    this.paritySelect = document.getElementById('parity');\n    this.flowControlSelect = document.getElementById('flowControl');\n    this.bufferInput = document.getElementById('buffer');\n  }\n\n  _attachEventListeners() {\n    // Select port button\n    this.selectPortBtn.addEventListener('click', async () => {\n      const selected = await this.serialConnection.selectPort();\n      if (selected) {\n        this.statusText.textContent = 'Port selected. Ready to connect.';\n        this.connectBtn.disabled = false;\n      }\n    });\n    \n    // Connect/disconnect button\n    this.connectBtn.addEventListener('click', async () => {\n      if (!this.isConnected) {\n        try {\n          const options = {\n            baudRate: parseInt(this.baudRateSelect.value),\n            dataBits: parseInt(this.dataBitsSelect.value),\n            stopBits: parseInt(this.stopBitsSelect.value),\n            parity: this.paritySelect.value,\n            flowControl: this.flowControlSelect.value\n          };\n          \n          await this.serialConnection.connect(options);\n          this._updateConnectionState(true);\n        } catch (error) {\n          this.statusText.textContent = `Connection error: ${error.message}`;\n        }\n      } else {\n        try {\n          await this.serialConnection.disconnect();\n          this._updateConnectionState(false);\n        } catch (error) {\n          this.statusText.textContent = `Disconnection error: ${error.message}`;\n        }\n      }\n    });\n    \n    // Listen for connection changes from the serial connection\n    this.serialConnection.onConnectionChange((connected) => {\n      this._updateConnectionState(connected);\n    });\n  }\n\n  _updateConnectionState(connected) {\n    this.isConnected = connected;\n    \n    if (connected) {\n      this.statusText.textContent = 'Connected';\n      this.connectBtn.textContent = 'Close Serial Port';\n      this.connectBtn.classList.replace('btn-success', 'btn-danger');\n      this.baudRateSelect.disabled = true;\n      this.dataBitsSelect.disabled = true;\n      this.stopBitsSelect.disabled = true;\n      this.paritySelect.disabled = true;\n      this.flowControlSelect.disabled = true;\n      this.bufferInput.disabled = true;\n    } else {\n      this.statusText.textContent = 'Disconnected';\n      this.connectBtn.textContent = 'Open Serial Port';\n      this.connectBtn.classList.replace('btn-danger', 'btn-success');\n      this.baudRateSelect.disabled = false;\n      this.dataBitsSelect.disabled = false;\n      this.stopBitsSelect.disabled = false;\n      this.paritySelect.disabled = false;\n      this.flowControlSelect.disabled = false;\n      this.bufferInput.disabled = false;\n    }\n  }\n}\n```",
      "testStrategy": "1. Test UI rendering in different browsers\n2. Verify all form controls are properly initialized\n3. Test port selection functionality\n4. Verify connection/disconnection UI state changes\n5. Test with different connection parameters\n6. Verify error messages are displayed correctly\n7. Test responsive layout on different screen sizes\n8. Verify accessibility of all UI elements",
      "priority": "medium",
      "dependencies": [
        1,
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Log Viewer UI",
      "description": "Create the main log viewer interface for displaying Modbus packets with filtering and control options.",
      "details": "1. Create the main log viewer UI with table layout\n2. Implement control bar with filtering options\n3. Add packet display with HEX and ASCII representation\n4. Implement auto-scroll functionality\n5. Add clear, copy, and export buttons\n\nExample implementation:\n```javascript\n// logViewerUI.js\nexport class LogViewerUI {\n  constructor() {\n    this.packets = [];\n    this.autoScroll = true;\n    this.filterType = 'all'; // 'all', 'tx', 'rx'\n    \n    // Cache DOM elements\n    this.mainContent = document.querySelector('.main-content');\n    \n    // Initialize UI\n    this._createUI();\n    this._attachEventListeners();\n  }\n\n  _createUI() {\n    this.mainContent.innerHTML = `\n      <div class=\"p-3 log-viewer\">\n        <div class=\"control-bar d-flex flex-wrap align-items-center mb-3\">\n          <div class=\"me-3 mb-2\">\n            <label for=\"packetTimeout\" class=\"form-label small mb-0\">Packet Timeout (ms)</label>\n            <input type=\"number\" class=\"form-control form-control-sm\" id=\"packetTimeout\" value=\"50\" min=\"10\" max=\"1000\">\n          </div>\n          \n          <div class=\"me-3 mb-2\">\n            <label for=\"logType\" class=\"form-label small mb-0\">Log Type</label>\n            <select class=\"form-select form-select-sm\" id=\"logType\">\n              <option value=\"all\" selected>All</option>\n              <option value=\"tx\">TX</option>\n              <option value=\"rx\">RX</option>\n            </select>\n          </div>\n          \n          <div class=\"form-check me-3 mb-2\">\n            <input class=\"form-check-input\" type=\"checkbox\" id=\"autoScroll\" checked>\n            <label class=\"form-check-label small\" for=\"autoScroll\">Auto Scroll</label>\n          </div>\n          \n          <button id=\"clearBtn\" class=\"btn btn-sm btn-outline-secondary me-2 mb-2\">Clear</button>\n          <button id=\"copyBtn\" class=\"btn btn-sm btn-outline-secondary me-2 mb-2\">Copy</button>\n          <button id=\"exportBtn\" class=\"btn btn-sm btn-outline-secondary me-2 mb-2\">Export</button>\n          <button id=\"optionsBtn\" class=\"btn btn-sm btn-outline-secondary me-2 mb-2\">System Options</button>\n          <button id=\"quickSendBtn\" class=\"btn btn-sm btn-outline-primary mb-2\">Quick Send</button>\n        </div>\n        \n        <div class=\"log-container bg-dark p-2 rounded\" style=\"height: calc(100vh - 250px); overflow-y: auto;\">\n          <table class=\"table table-dark table-hover table-sm log-table\">\n            <thead>\n              <tr>\n                <th width=\"30\"><input type=\"checkbox\" id=\"selectAll\"></th>\n                <th width=\"80\">Time</th>\n                <th width=\"50\">Dir</th>\n                <th width=\"60\">Slave</th>\n                <th width=\"80\">Function</th>\n                <th>Data (HEX)</th>\n                <th width=\"80\">CRC</th>\n                <th width=\"60\">Status</th>\n              </tr>\n            </thead>\n            <tbody id=\"logTableBody\">\n              <!-- Log entries will be inserted here -->\n            </tbody>\n          </table>\n        </div>\n        \n        <div class=\"message-input-area mt-3\">\n          <div class=\"input-group\">\n            <textarea class=\"form-control\" id=\"messageInput\" rows=\"2\" placeholder=\"Enter message to send...\"></textarea>\n            <button class=\"btn btn-primary\" id=\"sendBtn\">Send</button>\n          </div>\n          \n          <div class=\"d-flex flex-wrap mt-2\">\n            <div class=\"form-check me-3\">\n              <input class=\"form-check-input\" type=\"checkbox\" id=\"appendCRLF\">\n              <label class=\"form-check-label small\" for=\"appendCRLF\">Append CRLF</label>\n            </div>\n            \n            <div class=\"form-check me-3\">\n              <input class=\"form-check-input\" type=\"checkbox\" id=\"hexSend\">\n              <label class=\"form-check-label small\" for=\"hexSend\">HEX Send</label>\n            </div>\n            \n            <div class=\"form-check me-3\">\n              <input class=\"form-check-input\" type=\"checkbox\" id=\"loopSend\">\n              <label class=\"form-check-label small\" for=\"loopSend\">Loop Send</label>\n            </div>\n            \n            <div class=\"me-3\">\n              <label for=\"sendInterval\" class=\"form-label small mb-0\">Send Interval (ms)</label>\n              <input type=\"number\" class=\"form-control form-control-sm\" id=\"sendInterval\" value=\"1000\" min=\"100\">\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n    \n    // Cache new DOM elements\n    this.logTableBody = document.getElementById('logTableBody');\n    this.logContainer = document.querySelector('.log-container');\n    this.packetTimeoutInput = document.getElementById('packetTimeout');\n    this.logTypeSelect = document.getElementById('logType');\n    this.autoScrollCheckbox = document.getElementById('autoScroll');\n    this.clearBtn = document.getElementById('clearBtn');\n    this.copyBtn = document.getElementById('copyBtn');\n    this.exportBtn = document.getElementById('exportBtn');\n    this.messageInput = document.getElementById('messageInput');\n    this.sendBtn = document.getElementById('sendBtn');\n    this.hexSendCheckbox = document.getElementById('hexSend');\n    this.appendCRLFCheckbox = document.getElementById('appendCRLF');\n    this.loopSendCheckbox = document.getElementById('loopSend');\n    this.sendIntervalInput = document.getElementById('sendInterval');\n  }\n\n  _attachEventListeners() {\n    // Auto scroll toggle\n    this.autoScrollCheckbox.addEventListener('change', (e) => {\n      this.autoScroll = e.target.checked;\n    });\n    \n    // Log type filter\n    this.logTypeSelect.addEventListener('change', () => {\n      this.filterType = this.logTypeSelect.value;\n      this._refreshLogView();\n    });\n    \n    // Clear button\n    this.clearBtn.addEventListener('click', () => {\n      this.packets = [];\n      this.logTableBody.innerHTML = '';\n    });\n    \n    // Copy button\n    this.copyBtn.addEventListener('click', () => {\n      const text = this.packets.map(p => {\n        const direction = p.direction === 'TX' ? 'TX' : 'RX';\n        const hex = Array.from(p.rawData).map(b => b.toString(16).padStart(2, '0')).join(' ');\n        return `${direction}: ${hex}`;\n      }).join('\\n');\n      \n      navigator.clipboard.writeText(text).then(() => {\n        alert('Log copied to clipboard');\n      }).catch(err => {\n        console.error('Failed to copy: ', err);\n      });\n    });\n    \n    // Export button\n    this.exportBtn.addEventListener('click', () => {\n      const data = JSON.stringify(this.packets, null, 2);\n      const blob = new Blob([data], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      \n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `modbus-log-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    });\n  }\n\n  addPacket(packet) {\n    this.packets.push(packet);\n    \n    // Apply filter\n    if (this.filterType === 'all' || \n        (this.filterType === 'tx' && packet.direction === 'TX') || \n        (this.filterType === 'rx' && packet.direction === 'RX')) {\n      this._addPacketToTable(packet);\n    }\n  }\n\n  _addPacketToTable(packet) {\n    const { timestamp, direction, rawData, parsedData, interpretation } = packet;\n    const { slaveAddress, functionCode, data, crc, isValid } = parsedData;\n    \n    const row = document.createElement('tr');\n    row.className = direction === 'TX' ? 'table-primary' : 'table-success';\n    row.innerHTML = `\n      <td><input type=\"checkbox\" class=\"packet-select\"></td>\n      <td>${timestamp.toLocaleTimeString()}</td>\n      <td>${direction}</td>\n      <td>${slaveAddress}</td>\n      <td>${functionCode} (0x${functionCode.toString(16).padStart(2, '0')})</td>\n      <td>${Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ')}</td>\n      <td>${crc.toString(16).padStart(4, '0')}</td>\n      <td>${isValid ? 'Valid' : 'Error'}</td>\n    `;\n    \n    // Add tooltip with interpretation\n    row.title = interpretation;\n    \n    // Add click handler to show details\n    row.addEventListener('click', () => {\n      alert(interpretation);\n    });\n    \n    this.logTableBody.appendChild(row);\n    \n    // Auto scroll if enabled\n    if (this.autoScroll) {\n      this.logContainer.scrollTop = this.logContainer.scrollHeight;\n    }\n  }\n\n  _refreshLogView() {\n    this.logTableBody.innerHTML = '';\n    \n    this.packets.forEach(packet => {\n      if (this.filterType === 'all' || \n          (this.filterType === 'tx' && packet.direction === 'TX') || \n          (this.filterType === 'rx' && packet.direction === 'RX')) {\n        this._addPacketToTable(packet);\n      }\n    });\n  }\n\n  getPacketTimeout() {\n    return parseInt(this.packetTimeoutInput.value);\n  }\n}\n```",
      "testStrategy": "1. Test UI rendering in different browsers\n2. Verify packet display with various Modbus packets\n3. Test filtering functionality (All/TX/RX)\n4. Verify auto-scroll behavior\n5. Test clear, copy, and export functions\n6. Verify HEX and ASCII representation accuracy\n7. Test with large numbers of packets for performance\n8. Verify responsive layout on different screen sizes",
      "priority": "medium",
      "dependencies": [
        1,
        4
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Data Export and Storage",
      "description": "Create functionality to export captured communication logs and store session data locally.",
      "details": "1. Implement CSV and JSON export functionality\n2. Create local storage mechanism using IndexedDB\n3. Add session management for saving and loading captured data\n4. Implement packet statistics calculation\n\nExample implementation:\n```javascript\n// dataStorage.js\nexport class DataStorage {\n  constructor() {\n    this.db = null;\n    this.initDatabase();\n  }\n\n  async initDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open('ModbusMonitorDB', 1);\n      \n      request.onerror = (event) => {\n        console.error('IndexedDB error:', event.target.error);\n        reject(event.target.error);\n      };\n      \n      request.onsuccess = (event) => {\n        this.db = event.target.result;\n        resolve();\n      };\n      \n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        \n        // Create sessions store\n        if (!db.objectStoreNames.contains('sessions')) {\n          const sessionsStore = db.createObjectStore('sessions', { keyPath: 'id' });\n          sessionsStore.createIndex('startTime', 'startTime', { unique: false });\n        }\n        \n        // Create packets store\n        if (!db.objectStoreNames.contains('packets')) {\n          const packetsStore = db.createObjectStore('packets', { keyPath: 'id' });\n          packetsStore.createIndex('sessionId', 'sessionId', { unique: false });\n          packetsStore.createIndex('timestamp', 'timestamp', { unique: false });\n        }\n      };\n    });\n  }\n\n  async saveSession(session) {\n    if (!this.db) await this.initDatabase();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['sessions', 'packets'], 'readwrite');\n      const sessionsStore = transaction.objectStore('sessions');\n      const packetsStore = transaction.objectStore('packets');\n      \n      // Save session info\n      const sessionRequest = sessionsStore.put({\n        id: session.id,\n        startTime: session.startTime,\n        endTime: session.endTime,\n        connectionParams: session.connectionParams,\n        statistics: this.calculateStatistics(session.packets)\n      });\n      \n      sessionRequest.onerror = (event) => reject(event.target.error);\n      \n      // Save packets\n      session.packets.forEach(packet => {\n        const packetCopy = { ...packet, sessionId: session.id };\n        const packetRequest = packetsStore.put(packetCopy);\n        packetRequest.onerror = (event) => reject(event.target.error);\n      });\n      \n      transaction.oncomplete = () => resolve(session.id);\n      transaction.onerror = (event) => reject(event.target.error);\n    });\n  }\n\n  async loadSession(sessionId) {\n    if (!this.db) await this.initDatabase();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['sessions', 'packets'], 'readonly');\n      const sessionsStore = transaction.objectStore('sessions');\n      const packetsStore = transaction.objectStore('packets');\n      \n      // Get session info\n      const sessionRequest = sessionsStore.get(sessionId);\n      let session;\n      \n      sessionRequest.onsuccess = (event) => {\n        session = event.target.result;\n        if (!session) {\n          reject(new Error('Session not found'));\n          return;\n        }\n        \n        // Get packets for this session\n        const packetsIndex = packetsStore.index('sessionId');\n        const packetsRequest = packetsIndex.getAll(sessionId);\n        \n        packetsRequest.onsuccess = (event) => {\n          session.packets = event.target.result;\n          resolve(session);\n        };\n        \n        packetsRequest.onerror = (event) => reject(event.target.error);\n      };\n      \n      sessionRequest.onerror = (event) => reject(event.target.error);\n    });\n  }\n\n  async listSessions() {\n    if (!this.db) await this.initDatabase();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['sessions'], 'readonly');\n      const sessionsStore = transaction.objectStore('sessions');\n      const request = sessionsStore.getAll();\n      \n      request.onsuccess = (event) => {\n        resolve(event.target.result);\n      };\n      \n      request.onerror = (event) => reject(event.target.error);\n    });\n  }\n\n  async deleteSession(sessionId) {\n    if (!this.db) await this.initDatabase();\n    \n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(['sessions', 'packets'], 'readwrite');\n      const sessionsStore = transaction.objectStore('sessions');\n      const packetsStore = transaction.objectStore('packets');\n      \n      // Delete session\n      const sessionRequest = sessionsStore.delete(sessionId);\n      \n      // Delete all packets for this session\n      const packetsIndex = packetsStore.index('sessionId');\n      const packetsRequest = packetsIndex.openCursor(sessionId);\n      \n      packetsRequest.onsuccess = (event) => {\n        const cursor = event.target.result;\n        if (cursor) {\n          cursor.delete();\n          cursor.continue();\n        }\n      };\n      \n      transaction.oncomplete = () => resolve();\n      transaction.onerror = (event) => reject(event.target.error);\n    });\n  }\n\n  exportToCSV(packets) {\n    const headers = ['Timestamp', 'Direction', 'Slave Address', 'Function Code', 'Data', 'CRC', 'Valid', 'Interpretation'];\n    \n    const rows = packets.map(packet => {\n      const { timestamp, direction, parsedData, interpretation } = packet;\n      const { slaveAddress, functionCode, data, crc, isValid } = parsedData;\n      \n      return [\n        timestamp.toISOString(),\n        direction,\n        slaveAddress,\n        functionCode,\n        Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' '),\n        crc.toString(16).padStart(4, '0'),\n        isValid ? 'Yes' : 'No',\n        interpretation.replace(/\\n/g, ' ')\n      ];\n    });\n    \n    // Create CSV content\n    const csvContent = [\n      headers.join(','),\n      ...rows.map(row => row.map(cell => `\"${cell}\"`).join(','))\n    ].join('\\n');\n    \n    return csvContent;\n  }\n\n  exportToJSON(packets) {\n    return JSON.stringify(packets, (key, value) => {\n      // Convert Uint8Array to regular arrays for JSON serialization\n      if (value instanceof Uint8Array) {\n        return Array.from(value);\n      }\n      return value;\n    }, 2);\n  }\n\n  calculateStatistics(packets) {\n    const totalPackets = packets.length;\n    const txPackets = packets.filter(p => p.direction === 'TX').length;\n    const rxPackets = packets.filter(p => p.direction === 'RX').length;\n    const invalidPackets = packets.filter(p => !p.parsedData.isValid).length;\n    const errorRate = totalPackets > 0 ? (invalidPackets / totalPackets) * 100 : 0;\n    \n    // Calculate response times (time between TX and corresponding RX)\n    const responseTimes = [];\n    for (let i = 0; i < packets.length - 1; i++) {\n      if (packets[i].direction === 'TX' && packets[i+1].direction === 'RX') {\n        const responseTime = packets[i+1].timestamp - packets[i].timestamp;\n        responseTimes.push(responseTime);\n      }\n    }\n    \n    const avgResponseTime = responseTimes.length > 0 ? \n      responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length : \n      0;\n    \n    return {\n      totalPackets,\n      txPackets,\n      rxPackets,\n      invalidPackets,\n      errorRate: errorRate.toFixed(2) + '%',\n      avgResponseTime: avgResponseTime.toFixed(2) + 'ms',\n      minResponseTime: Math.min(...responseTimes, Number.MAX_SAFE_INTEGER).toFixed(2) + 'ms',\n      maxResponseTime: Math.max(...responseTimes, 0).toFixed(2) + 'ms'\n    };\n  }\n}\n```",
      "testStrategy": "1. Test CSV export with various packet types\n2. Verify JSON export format and data integrity\n3. Test IndexedDB storage with large datasets\n4. Verify session saving and loading functionality\n5. Test statistics calculation accuracy\n6. Verify data persistence across browser refreshes\n7. Test with various browsers for IndexedDB compatibility\n8. Verify error handling for storage failures",
      "priority": "medium",
      "dependencies": [
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Message Sending Interface",
      "description": "Create the interface and functionality for sending custom Modbus messages, including hex input and looped sending.",
      "details": "1. Implement the message input area UI\n2. Add support for hex and text input modes\n3. Implement CRLF appending option\n4. Create loop sending functionality with interval control\n5. Add validation for input formats\n\nExample implementation:\n```javascript\n// messageSender.js\nexport class MessageSender {\n  constructor(serialDataHandler) {\n    this.serialDataHandler = serialDataHandler;\n    this.loopInterval = null;\n    \n    // Cache DOM elements\n    this.messageInput = document.getElementById('messageInput');\n    this.sendBtn = document.getElementById('sendBtn');\n    this.hexSendCheckbox = document.getElementById('hexSend');\n    this.appendCRLFCheckbox = document.getElementById('appendCRLF');\n    this.loopSendCheckbox = document.getElementById('loopSend');\n    this.sendIntervalInput = document.getElementById('sendInterval');\n    \n    this._attachEventListeners();\n  }\n\n  _attachEventListeners() {\n    // Send button\n    this.sendBtn.addEventListener('click', () => {\n      this.sendMessage();\n    });\n    \n    // Enter key in textarea\n    this.messageInput.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter' && e.ctrlKey) {\n        e.preventDefault();\n        this.sendMessage();\n      }\n    });\n    \n    // Loop send checkbox\n    this.loopSendCheckbox.addEventListener('change', (e) => {\n      if (e.target.checked) {\n        this.startLoopSend();\n      } else {\n        this.stopLoopSend();\n      }\n    });\n  }\n\n  async sendMessage() {\n    const message = this.messageInput.value.trim();\n    if (!message) return;\n    \n    const isHex = this.hexSendCheckbox.checked;\n    let dataToSend = message;\n    \n    // Validate hex format if hex mode is enabled\n    if (isHex) {\n      const hexPattern = /^([0-9A-Fa-f]{2}\\s*)+$/;\n      if (!hexPattern.test(message)) {\n        alert('Invalid hex format. Please use pairs of hex digits (e.g., \"01 03 00 00 00 0A C5 CD\")');\n        return;\n      }\n    } else if (this.appendCRLFCheckbox.checked) {\n      // Append CRLF if needed\n      dataToSend += '\\r\\n';\n    }\n    \n    try {\n      await this.serialDataHandler.sendData(dataToSend, isHex);\n    } catch (error) {\n      console.error('Error sending message:', error);\n      alert(`Failed to send message: ${error.message}`);\n    }\n  }\n\n  startLoopSend() {\n    if (this.loopInterval) return;\n    \n    const interval = parseInt(this.sendIntervalInput.value);\n    if (isNaN(interval) || interval < 100) {\n      alert('Send interval must be at least 100ms');\n      this.loopSendCheckbox.checked = false;\n      return;\n    }\n    \n    this.sendMessage(); // Send immediately first\n    \n    this.loopInterval = setInterval(() => {\n      this.sendMessage();\n    }, interval);\n    \n    // Disable inputs during loop sending\n    this.sendIntervalInput.disabled = true;\n  }\n\n  stopLoopSend() {\n    if (this.loopInterval) {\n      clearInterval(this.loopInterval);\n      this.loopInterval = null;\n      \n      // Re-enable inputs\n      this.sendIntervalInput.disabled = false;\n    }\n  }\n\n  validateHexInput(input) {\n    // Remove all whitespace\n    const hexString = input.replace(/\\s/g, '');\n    \n    // Check if string has even length and contains only hex characters\n    return hexString.length % 2 === 0 && /^[0-9A-Fa-f]+$/.test(hexString);\n  }\n\n  // Helper to convert hex string to byte array\n  hexStringToBytes(hexString) {\n    // Remove all whitespace\n    const hex = hexString.replace(/\\s/g, '');\n    \n    // Convert to byte array\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n      bytes[i/2] = parseInt(hex.substr(i, 2), 16);\n    }\n    \n    return bytes;\n  }\n}\n```",
      "testStrategy": "1. Test sending messages in text mode\n2. Verify hex input validation\n3. Test CRLF appending functionality\n4. Verify loop sending with different intervals\n5. Test error handling for invalid inputs\n6. Verify keyboard shortcuts (Ctrl+Enter)\n7. Test with various Modbus message formats\n8. Verify UI state changes during loop sending",
      "priority": "medium",
      "dependencies": [
        3,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement PWA Functionality",
      "description": "Add Progressive Web App capabilities to allow offline usage and improved user experience.",
      "details": "1. Create a service worker for offline caching\n2. Add manifest.json for PWA installation\n3. Implement offline fallback page\n4. Add install prompt handling\n5. Configure cache strategies for assets\n\nExample implementation:\n```javascript\n// service-worker.js\nconst CACHE_NAME = 'modbus-monitor-v1';\nconst ASSETS_TO_CACHE = [\n  '/',\n  '/index.html',\n  '/css/bootstrap.min.css',\n  '/css/styles.css',\n  '/js/main.js',\n  '/js/modules/serialConnection.js',\n  '/js/modules/serialDataHandler.js',\n  '/js/modules/modbusParser.js',\n  '/js/modules/modbusInterpreter.js',\n  '/js/modules/connectionUI.js',\n  '/js/modules/logViewerUI.js',\n  '/js/modules/dataStorage.js',\n  '/js/modules/messageSender.js',\n  '/offline.html',\n  '/manifest.json',\n  '/icons/icon-192x192.png',\n  '/icons/icon-512x512.png'\n];\n\n// Install event - cache assets\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then((cache) => {\n        return cache.addAll(ASSETS_TO_CACHE);\n      })\n      .then(() => self.skipWaiting())\n  );\n});\n\n// Activate event - clean up old caches\nself.addEventListener('activate', (event) => {\n  event.waitUntil(\n    caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.filter((name) => name !== CACHE_NAME)\n          .map((name) => caches.delete(name))\n      );\n    })\n    .then(() => self.clients.claim())\n  );\n});\n\n// Fetch event - serve from cache or network\nself.addEventListener('fetch', (event) => {\n  // Skip non-GET requests and browser extensions\n  if (event.request.method !== 'GET' || event.request.url.startsWith('chrome-extension://')) {\n    return;\n  }\n  \n  event.respondWith(\n    caches.match(event.request)\n      .then((cachedResponse) => {\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n        \n        return fetch(event.request)\n          .then((response) => {\n            // Don't cache responses that aren't successful\n            if (!response || response.status !== 200 || response.type !== 'basic') {\n              return response;\n            }\n            \n            // Clone the response as it can only be consumed once\n            const responseToCache = response.clone();\n            \n            caches.open(CACHE_NAME)\n              .then((cache) => {\n                cache.put(event.request, responseToCache);\n              });\n            \n            return response;\n          })\n          .catch(() => {\n            // If network request fails and it's a document, serve the offline page\n            if (event.request.headers.get('Accept').includes('text/html')) {\n              return caches.match('/offline.html');\n            }\n          });\n      })\n  );\n});\n```\n\nAnd create a manifest.json file:\n\n```json\n{\n  \"name\": \"Modbus-RTU Serial Monitor\",\n  \"short_name\": \"Modbus Monitor\",\n  \"description\": \"Web-based Modbus-RTU protocol monitoring tool\",\n  \"start_url\": \"/index.html\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#212529\",\n  \"theme_color\": \"#0d6efd\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any maskable\"\n    },\n    {\n      \"src\": \"/icons/icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any maskable\"\n    }\n  ]\n}\n```\n\nAdd registration code in main.js:\n\n```javascript\n// Register service worker\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/service-worker.js')\n      .then((registration) => {\n        console.log('ServiceWorker registration successful with scope:', registration.scope);\n      })\n      .catch((error) => {\n        console.error('ServiceWorker registration failed:', error);\n      });\n  });\n}\n```",
      "testStrategy": "1. Test service worker installation and activation\n2. Verify offline functionality by disabling network\n3. Test PWA installation on desktop and mobile devices\n4. Verify caching of static assets\n5. Test offline fallback page\n6. Verify PWA updates when new versions are deployed\n7. Test on various browsers and devices\n8. Verify manifest.json is properly configured",
      "priority": "low",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Application State Management",
      "description": "Create a central state management system to coordinate between different modules and maintain application state.",
      "details": "1. Implement a central state manager using the Observer pattern\n2. Create state synchronization between UI components\n3. Add persistence of user preferences\n4. Implement error handling and notification system\n\nExample implementation:\n```javascript\n// appState.js\nexport class AppState {\n  constructor() {\n    this.state = {\n      connection: {\n        isConnected: false,\n        port: null,\n        settings: {\n          baudRate: 115200,\n          dataBits: 8,\n          stopBits: 1,\n          parity: 'none',\n          flowControl: 'none',\n          bufferSize: 4096\n        }\n      },\n      monitoring: {\n        isActive: false,\n        packetTimeout: 50,\n        autoScroll: true,\n        filterType: 'all'\n      },\n      session: {\n        id: null,\n        startTime: null,\n        packets: [],\n        statistics: null\n      },\n      ui: {\n        theme: 'dark',\n        selectedPackets: [],\n        notifications: []\n      }\n    };\n    \n    this.listeners = {};\n    this.loadPreferences();\n  }\n\n  // Get a specific part of the state\n  get(path) {\n    return this._getNestedProperty(this.state, path);\n  }\n\n  // Update state and notify listeners\n  update(path, value) {\n    this._setNestedProperty(this.state, path, value);\n    this._notifyListeners(path);\n    this.savePreferences();\n    return this;\n  }\n\n  // Subscribe to state changes\n  subscribe(path, callback) {\n    if (!this.listeners[path]) {\n      this.listeners[path] = [];\n    }\n    \n    this.listeners[path].push(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      this.listeners[path] = this.listeners[path].filter(cb => cb !== callback);\n    };\n  }\n\n  // Add a notification\n  notify(message, type = 'info', duration = 5000) {\n    const notification = {\n      id: Date.now(),\n      message,\n      type,\n      timestamp: new Date()\n    };\n    \n    const notifications = [...this.state.ui.notifications, notification];\n    this.update('ui.notifications', notifications);\n    \n    // Auto-remove after duration\n    if (duration > 0) {\n      setTimeout(() => {\n        this.dismissNotification(notification.id);\n      }, duration);\n    }\n    \n    return notification.id;\n  }\n\n  // Remove a notification\n  dismissNotification(id) {\n    const notifications = this.state.ui.notifications.filter(n => n.id !== id);\n    this.update('ui.notifications', notifications);\n  }\n\n  // Add a packet to the current session\n  addPacket(packet) {\n    const packets = [...this.state.session.packets, packet];\n    this.update('session.packets', packets);\n    \n    // Update statistics\n    if (packets.length % 10 === 0) { // Update stats every 10 packets\n      this._updateStatistics();\n    }\n  }\n\n  // Start a new session\n  startSession() {\n    const sessionId = 'session_' + Date.now();\n    const startTime = new Date();\n    \n    this.update('session', {\n      id: sessionId,\n      startTime,\n      packets: [],\n      statistics: null\n    });\n    \n    return sessionId;\n  }\n\n  // End current session and save\n  async endSession() {\n    if (!this.state.session.id) return null;\n    \n    const endTime = new Date();\n    this.update('session.endTime', endTime);\n    this._updateStatistics();\n    \n    // Save to storage if available\n    if (this.dataStorage) {\n      try {\n        await this.dataStorage.saveSession(this.state.session);\n        this.notify('Session saved successfully', 'success');\n      } catch (error) {\n        console.error('Error saving session:', error);\n        this.notify('Failed to save session: ' + error.message, 'error');\n      }\n    }\n    \n    return this.state.session.id;\n  }\n\n  // Set data storage reference\n  setDataStorage(dataStorage) {\n    this.dataStorage = dataStorage;\n  }\n\n  // Save user preferences to localStorage\n  savePreferences() {\n    const preferences = {\n      connection: {\n        settings: this.state.connection.settings\n      },\n      monitoring: {\n        packetTimeout: this.state.monitoring.packetTimeout,\n        autoScroll: this.state.monitoring.autoScroll,\n        filterType: this.state.monitoring.filterType\n      },\n      ui: {\n        theme: this.state.ui.theme\n      }\n    };\n    \n    try {\n      localStorage.setItem('modbusMonitorPrefs', JSON.stringify(preferences));\n    } catch (error) {\n      console.error('Error saving preferences:', error);\n    }\n  }\n\n  // Load user preferences from localStorage\n  loadPreferences() {\n    try {\n      const prefsJson = localStorage.getItem('modbusMonitorPrefs');\n      if (prefsJson) {\n        const prefs = JSON.parse(prefsJson);\n        \n        // Update state with saved preferences\n        if (prefs.connection?.settings) {\n          this.update('connection.settings', {\n            ...this.state.connection.settings,\n            ...prefs.connection.settings\n          });\n        }\n        \n        if (prefs.monitoring) {\n          if (prefs.monitoring.packetTimeout) {\n            this.update('monitoring.packetTimeout', prefs.monitoring.packetTimeout);\n          }\n          if (typeof prefs.monitoring.autoScroll === 'boolean') {\n            this.update('monitoring.autoScroll', prefs.monitoring.autoScroll);\n          }\n          if (prefs.monitoring.filterType) {\n            this.update('monitoring.filterType', prefs.monitoring.filterType);\n          }\n        }\n        \n        if (prefs.ui?.theme) {\n          this.update('ui.theme', prefs.ui.theme);\n        }\n      }\n    } catch (error) {\n      console.error('Error loading preferences:', error);\n    }\n  }\n\n  // Update session statistics\n  _updateStatistics() {\n    if (!this.state.session.packets.length) return;\n    \n    const packets = this.state.session.packets;\n    const totalPackets = packets.length;\n    const txPackets = packets.filter(p => p.direction === 'TX').length;\n    const rxPackets = packets.filter(p => p.direction === 'RX').length;\n    const invalidPackets = packets.filter(p => !p.parsedData.isValid).length;\n    const errorRate = totalPackets > 0 ? (invalidPackets / totalPackets) * 100 : 0;\n    \n    // Calculate response times\n    const responseTimes = [];\n    for (let i = 0; i < packets.length - 1; i++) {\n      if (packets[i].direction === 'TX' && packets[i+1].direction === 'RX') {\n        const responseTime = packets[i+1].timestamp - packets[i].timestamp;\n        responseTimes.push(responseTime);\n      }\n    }\n    \n    const avgResponseTime = responseTimes.length > 0 ? \n      responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length : \n      0;\n    \n    const statistics = {\n      totalPackets,\n      txPackets,\n      rxPackets,\n      invalidPackets,\n      errorRate: errorRate.toFixed(2) + '%',\n      avgResponseTime: avgResponseTime.toFixed(2) + 'ms',\n      minResponseTime: responseTimes.length > 0 ? Math.min(...responseTimes).toFixed(2) + 'ms' : 'N/A',\n      maxResponseTime: responseTimes.length > 0 ? Math.max(...responseTimes).toFixed(2) + 'ms' : 'N/A'\n    };\n    \n    this.update('session.statistics', statistics);\n  }\n\n  // Helper to get nested property using dot notation\n  _getNestedProperty(obj, path) {\n    return path.split('.').reduce((prev, curr) => {\n      return prev ? prev[curr] : undefined;\n    }, obj);\n  }\n\n  // Helper to set nested property using dot notation\n  _setNestedProperty(obj, path, value) {\n    const parts = path.split('.');\n    const lastKey = parts.pop();\n    const target = parts.reduce((prev, curr) => {\n      if (!prev[curr]) prev[curr] = {};\n      return prev[curr];\n    }, obj);\n    \n    target[lastKey] = value;\n  }\n\n  // Notify all listeners for a path and its parent paths\n  _notifyListeners(path) {\n    // Notify specific path listeners\n    if (this.listeners[path]) {\n      this.listeners[path].forEach(callback => {\n        callback(this._getNestedProperty(this.state, path));\n      });\n    }\n    \n    // Notify parent path listeners\n    const parts = path.split('.');\n    while (parts.length > 1) {\n      parts.pop();\n      const parentPath = parts.join('.');\n      \n      if (this.listeners[parentPath]) {\n        this.listeners[parentPath].forEach(callback => {\n          callback(this._getNestedProperty(this.state, parentPath));\n        });\n      }\n    }\n    \n    // Notify root listeners\n    if (this.listeners['*']) {\n      this.listeners['*'].forEach(callback => {\n        callback(this.state);\n      });\n    }\n  }\n}\n```",
      "testStrategy": "1. Test state updates and listener notifications\n2. Verify persistence of user preferences\n3. Test notification system\n4. Verify state synchronization between components\n5. Test session management functionality\n6. Verify statistics calculation\n7. Test error handling and recovery\n8. Verify performance with frequent state updates",
      "priority": "high",
      "dependencies": [
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Main Application Integration",
      "description": "Integrate all modules into a cohesive application and implement the main entry point.",
      "details": "1. Create the main application class to coordinate all modules\n2. Implement initialization sequence\n3. Set up event handling between components\n4. Add error handling and recovery mechanisms\n5. Implement application lifecycle management\n\nExample implementation:\n```javascript\n// main.js\nimport { SerialConnection } from './modules/serialConnection.js';\nimport { SerialDataHandler } from './modules/serialDataHandler.js';\nimport { ModbusParser } from './modules/modbusParser.js';\nimport { ModbusInterpreter } from './modules/modbusInterpreter.js';\nimport { ConnectionUI } from './modules/connectionUI.js';\nimport { LogViewerUI } from './modules/logViewerUI.js';\nimport { DataStorage } from './modules/dataStorage.js';\nimport { MessageSender } from './modules/messageSender.js';\nimport { AppState } from './modules/appState.js';\n\nclass ModbusMonitorApp {\n  constructor() {\n    // Initialize state manager\n    this.appState = new AppState();\n    \n    // Initialize modules\n    this.serialConnection = new SerialConnection();\n    this.serialDataHandler = new SerialDataHandler(this.serialConnection);\n    this.modbusParser = new ModbusParser(this.appState.get('monitoring.packetTimeout'));\n    this.modbusInterpreter = new ModbusInterpreter();\n    this.dataStorage = new DataStorage();\n    \n    // Set data storage reference in app state\n    this.appState.setDataStorage(this.dataStorage);\n    \n    // Initialize UI components\n    this.connectionUI = new ConnectionUI(this.serialConnection, this.appState);\n    this.logViewerUI = new LogViewerUI(this.appState);\n    this.messageSender = new MessageSender(this.serialDataHandler, this.appState);\n    \n    // Set up event listeners\n    this._setupEventListeners();\n    \n    // Register service worker\n    this._registerServiceWorker();\n    \n    // Initialize UI based on state\n    this._initializeUI();\n  }\n\n  _setupEventListeners() {\n    // Listen for connection changes\n    this.serialConnection.onConnectionChange((isConnected) => {\n      this.appState.update('connection.isConnected', isConnected);\n      \n      if (isConnected) {\n        // Start a new session when connected\n        this.appState.startSession();\n        \n        // Start reading data\n        this.serialDataHandler.startReading();\n        \n        // Update monitoring state\n        this.appState.update('monitoring.isActive', true);\n      } else {\n        // End session when disconnected\n        if (this.appState.get('session.id')) {\n          this.appState.endSession();\n        }\n        \n        // Stop reading data\n        this.serialDataHandler.stopReading();\n        \n        // Update monitoring state\n        this.appState.update('monitoring.isActive', false);\n      }\n    });\n    \n    // Listen for received data\n    this.serialDataHandler.onDataReceived((data) => {\n      // Process data with Modbus parser\n      this.modbusParser.processBytes(data.data, data.timestamp);\n    });\n    \n    // Listen for detected Modbus packets\n    this.modbusParser.onPacketDetected((packet) => {\n      // Add interpretation\n      packet.interpretation = this.modbusInterpreter.interpretPacket(packet);\n      \n      // Add to app state\n      this.appState.addPacket(packet);\n      \n      // Update UI\n      this.logViewerUI.addPacket(packet);\n    });\n    \n    // Listen for packet timeout changes\n    this.appState.subscribe('monitoring.packetTimeout', (timeout) => {\n      this.modbusParser.setPacketTimeout(timeout);\n    });\n    \n    // Listen for errors\n    window.addEventListener('error', (event) => {\n      this.appState.notify(`Error: ${event.message}`, 'error');\n      console.error('Application error:', event);\n    });\n    \n    // Listen for unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      this.appState.notify(`Promise error: ${event.reason}`, 'error');\n      console.error('Unhandled promise rejection:', event);\n    });\n  }\n\n  _initializeUI() {\n    // Apply theme\n    document.body.classList.toggle('dark-theme', this.appState.get('ui.theme') === 'dark');\n    \n    // Set initial values from state\n    const packetTimeout = this.appState.get('monitoring.packetTimeout');\n    this.modbusParser.setPacketTimeout(packetTimeout);\n    \n    // Display welcome notification\n    this.appState.notify('Welcome to Modbus-RTU Serial Monitor', 'info', 3000);\n  }\n\n  _registerServiceWorker() {\n    if ('serviceWorker' in navigator) {\n      window.addEventListener('load', () => {\n        navigator.serviceWorker.register('/service-worker.js')\n          .then((registration) => {\n            console.log('ServiceWorker registration successful with scope:', registration.scope);\n          })\n          .catch((error) => {\n            console.error('ServiceWorker registration failed:', error);\n          });\n      });\n    }\n  }\n}\n\n// Initialize application when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  window.app = new ModbusMonitorApp();\n});\n```",
      "testStrategy": "1. Test complete application initialization\n2. Verify integration between all modules\n3. Test error handling and recovery\n4. Verify application state management\n5. Test full communication flow from serial connection to UI\n6. Verify service worker registration\n7. Test application with real Modbus devices\n8. Perform end-to-end testing of all user flows",
      "priority": "high",
      "dependencies": [
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}