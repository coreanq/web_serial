# Task ID: 5
# Title: Implement Modbus Function Code Interpreter
# Status: done
# Dependencies: 4
# Priority: medium
# Description: Create a module to interpret Modbus function codes and provide human-readable explanations of packet contents.
# Details:
1. Implement detailed interpretation for standard Modbus function codes (01-06, 15-16)
2. Add support for exception responses
3. Create register address and value formatting (decimal and hex)
4. Implement data payload interpretation based on function code

Example implementation:
```javascript
// modbusInterpreter.js
export class ModbusInterpreter {
  constructor() {
    this.functionCodeMap = {
      1: 'Read Coils',
      2: 'Read Discrete Inputs',
      3: 'Read Holding Registers',
      4: 'Read Input Registers',
      5: 'Write Single Coil',
      6: 'Write Single Register',
      15: 'Write Multiple Coils',
      16: 'Write Multiple Registers'
    };
    
    this.exceptionCodeMap = {
      1: 'Illegal Function',
      2: 'Illegal Data Address',
      3: 'Illegal Data Value',
      4: 'Slave Device Failure',
      5: 'Acknowledge',
      6: 'Slave Device Busy',
      8: 'Memory Parity Error',
      10: 'Gateway Path Unavailable',
      11: 'Gateway Target Device Failed to Respond'
    };
  }

  interpretPacket(packet) {
    const { slaveAddress, functionCode, data } = packet.parsedData;
    let interpretation = '';
    
    // Check if it's an exception response
    if (functionCode > 128) {
      const originalFunctionCode = functionCode - 128;
      const exceptionCode = data[0];
      
      interpretation = `Exception Response - ${this.getFunctionName(originalFunctionCode)}\n`;
      interpretation += `Exception: ${this.getExceptionName(exceptionCode)}\n`;
      return interpretation;
    }
    
    // Regular function code interpretation
    interpretation = `${this.getFunctionName(functionCode)}\n`;
    
    switch (functionCode) {
      case 1: // Read Coils
      case 2: // Read Discrete Inputs
        if (data.length === 0) {
          // Request
          const startAddress = (data[0] << 8) | data[1];
          const quantity = (data[2] << 8) | data[3];
          interpretation += `Start Address: ${startAddress} (0x${startAddress.toString(16)})\n`;
          interpretation += `Quantity: ${quantity}\n`;
        } else {
          // Response
          const byteCount = data[0];
          interpretation += `Byte Count: ${byteCount}\n`;
          interpretation += 'Values: ';
          
          for (let i = 1; i <= byteCount; i++) {
            interpretation += data[i].toString(16).padStart(2, '0') + ' ';
          }
        }
        break;
        
      case 3: // Read Holding Registers
      case 4: // Read Input Registers
        if (data.length === 4) {
          // Request
          const startAddress = (data[0] << 8) | data[1];
          const quantity = (data[2] << 8) | data[3];
          interpretation += `Start Address: ${startAddress} (0x${startAddress.toString(16)})\n`;
          interpretation += `Quantity: ${quantity}\n`;
        } else {
          // Response
          const byteCount = data[0];
          interpretation += `Byte Count: ${byteCount}\n`;
          interpretation += 'Register Values:\n';
          
          for (let i = 1; i < data.length; i += 2) {
            const regValue = (data[i] << 8) | data[i + 1];
            interpretation += `  ${regValue} (0x${regValue.toString(16).padStart(4, '0')})\n`;
          }
        }
        break;
        
      case 5: // Write Single Coil
        const outputAddress = (data[0] << 8) | data[1];
        const outputValue = (data[2] << 8) | data[3];
        interpretation += `Output Address: ${outputAddress} (0x${outputAddress.toString(16)})\n`;
        interpretation += `Value: ${outputValue === 0xFF00 ? 'ON' : 'OFF'}\n`;
        break;
        
      case 6: // Write Single Register
        const regAddress = (data[0] << 8) | data[1];
        const regValue = (data[2] << 8) | data[3];
        interpretation += `Register Address: ${regAddress} (0x${regAddress.toString(16)})\n`;
        interpretation += `Value: ${regValue} (0x${regValue.toString(16).padStart(4, '0')})\n`;
        break;
        
      // Add cases for 15 and 16 here
      
      default:
        interpretation += 'Detailed interpretation not available\n';
    }
    
    return interpretation;
  }

  getFunctionName(functionCode) {
    return this.functionCodeMap[functionCode] || `Unknown Function (${functionCode})`;
  }

  getExceptionName(exceptionCode) {
    return this.exceptionCodeMap[exceptionCode] || `Unknown Exception (${exceptionCode})`;
  }
}
```

# Test Strategy:
1. Test interpretation of all standard function codes
2. Verify correct handling of exception responses
3. Test with various data payloads for each function code
4. Verify decimal and hexadecimal representations are correct
5. Test edge cases like maximum register counts
6. Verify interpretation of real-world Modbus packets
7. Test with malformed packets to ensure graceful handling
8. Verify readability and accuracy of human-readable output
