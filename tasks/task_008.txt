# Task ID: 8
# Title: Implement Data Export and Storage
# Status: pending
# Dependencies: 4, 7
# Priority: medium
# Description: Create functionality to export captured communication logs and store session data locally.
# Details:
1. Implement CSV and JSON export functionality
2. Create local storage mechanism using IndexedDB
3. Add session management for saving and loading captured data
4. Implement packet statistics calculation

Example implementation:
```javascript
// dataStorage.js
export class DataStorage {
  constructor() {
    this.db = null;
    this.initDatabase();
  }

  async initDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('ModbusMonitorDB', 1);
      
      request.onerror = (event) => {
        console.error('IndexedDB error:', event.target.error);
        reject(event.target.error);
      };
      
      request.onsuccess = (event) => {
        this.db = event.target.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Create sessions store
        if (!db.objectStoreNames.contains('sessions')) {
          const sessionsStore = db.createObjectStore('sessions', { keyPath: 'id' });
          sessionsStore.createIndex('startTime', 'startTime', { unique: false });
        }
        
        // Create packets store
        if (!db.objectStoreNames.contains('packets')) {
          const packetsStore = db.createObjectStore('packets', { keyPath: 'id' });
          packetsStore.createIndex('sessionId', 'sessionId', { unique: false });
          packetsStore.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }

  async saveSession(session) {
    if (!this.db) await this.initDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['sessions', 'packets'], 'readwrite');
      const sessionsStore = transaction.objectStore('sessions');
      const packetsStore = transaction.objectStore('packets');
      
      // Save session info
      const sessionRequest = sessionsStore.put({
        id: session.id,
        startTime: session.startTime,
        endTime: session.endTime,
        connectionParams: session.connectionParams,
        statistics: this.calculateStatistics(session.packets)
      });
      
      sessionRequest.onerror = (event) => reject(event.target.error);
      
      // Save packets
      session.packets.forEach(packet => {
        const packetCopy = { ...packet, sessionId: session.id };
        const packetRequest = packetsStore.put(packetCopy);
        packetRequest.onerror = (event) => reject(event.target.error);
      });
      
      transaction.oncomplete = () => resolve(session.id);
      transaction.onerror = (event) => reject(event.target.error);
    });
  }

  async loadSession(sessionId) {
    if (!this.db) await this.initDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['sessions', 'packets'], 'readonly');
      const sessionsStore = transaction.objectStore('sessions');
      const packetsStore = transaction.objectStore('packets');
      
      // Get session info
      const sessionRequest = sessionsStore.get(sessionId);
      let session;
      
      sessionRequest.onsuccess = (event) => {
        session = event.target.result;
        if (!session) {
          reject(new Error('Session not found'));
          return;
        }
        
        // Get packets for this session
        const packetsIndex = packetsStore.index('sessionId');
        const packetsRequest = packetsIndex.getAll(sessionId);
        
        packetsRequest.onsuccess = (event) => {
          session.packets = event.target.result;
          resolve(session);
        };
        
        packetsRequest.onerror = (event) => reject(event.target.error);
      };
      
      sessionRequest.onerror = (event) => reject(event.target.error);
    });
  }

  async listSessions() {
    if (!this.db) await this.initDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['sessions'], 'readonly');
      const sessionsStore = transaction.objectStore('sessions');
      const request = sessionsStore.getAll();
      
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      
      request.onerror = (event) => reject(event.target.error);
    });
  }

  async deleteSession(sessionId) {
    if (!this.db) await this.initDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['sessions', 'packets'], 'readwrite');
      const sessionsStore = transaction.objectStore('sessions');
      const packetsStore = transaction.objectStore('packets');
      
      // Delete session
      const sessionRequest = sessionsStore.delete(sessionId);
      
      // Delete all packets for this session
      const packetsIndex = packetsStore.index('sessionId');
      const packetsRequest = packetsIndex.openCursor(sessionId);
      
      packetsRequest.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          cursor.delete();
          cursor.continue();
        }
      };
      
      transaction.oncomplete = () => resolve();
      transaction.onerror = (event) => reject(event.target.error);
    });
  }

  exportToCSV(packets) {
    const headers = ['Timestamp', 'Direction', 'Slave Address', 'Function Code', 'Data', 'CRC', 'Valid', 'Interpretation'];
    
    const rows = packets.map(packet => {
      const { timestamp, direction, parsedData, interpretation } = packet;
      const { slaveAddress, functionCode, data, crc, isValid } = parsedData;
      
      return [
        timestamp.toISOString(),
        direction,
        slaveAddress,
        functionCode,
        Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' '),
        crc.toString(16).padStart(4, '0'),
        isValid ? 'Yes' : 'No',
        interpretation.replace(/\n/g, ' ')
      ];
    });
    
    // Create CSV content
    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');
    
    return csvContent;
  }

  exportToJSON(packets) {
    return JSON.stringify(packets, (key, value) => {
      // Convert Uint8Array to regular arrays for JSON serialization
      if (value instanceof Uint8Array) {
        return Array.from(value);
      }
      return value;
    }, 2);
  }

  calculateStatistics(packets) {
    const totalPackets = packets.length;
    const txPackets = packets.filter(p => p.direction === 'TX').length;
    const rxPackets = packets.filter(p => p.direction === 'RX').length;
    const invalidPackets = packets.filter(p => !p.parsedData.isValid).length;
    const errorRate = totalPackets > 0 ? (invalidPackets / totalPackets) * 100 : 0;
    
    // Calculate response times (time between TX and corresponding RX)
    const responseTimes = [];
    for (let i = 0; i < packets.length - 1; i++) {
      if (packets[i].direction === 'TX' && packets[i+1].direction === 'RX') {
        const responseTime = packets[i+1].timestamp - packets[i].timestamp;
        responseTimes.push(responseTime);
      }
    }
    
    const avgResponseTime = responseTimes.length > 0 ? 
      responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length : 
      0;
    
    return {
      totalPackets,
      txPackets,
      rxPackets,
      invalidPackets,
      errorRate: errorRate.toFixed(2) + '%',
      avgResponseTime: avgResponseTime.toFixed(2) + 'ms',
      minResponseTime: Math.min(...responseTimes, Number.MAX_SAFE_INTEGER).toFixed(2) + 'ms',
      maxResponseTime: Math.max(...responseTimes, 0).toFixed(2) + 'ms'
    };
  }
}
```

# Test Strategy:
1. Test CSV export with various packet types
2. Verify JSON export format and data integrity
3. Test IndexedDB storage with large datasets
4. Verify session saving and loading functionality
5. Test statistics calculation accuracy
6. Verify data persistence across browser refreshes
7. Test with various browsers for IndexedDB compatibility
8. Verify error handling for storage failures
